package com.orch.daemon.vmware

import java.net.ServerSocket
import java.io.IOException
import akka.actor.{ Actor, ActorRef, Props , ActorContext, ActorSelection }
import scala.collection.mutable.Queue
import com.orch.daemon.kvm._
import com.orch.daemon._

import akka.io.{ IO, Tcp }
import akka.actor.{ Actor, ActorRef, Props }
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

/**
  * FileIO is a simple file transfert module
  * It use curl to acquire files from external nodes
  * And provide a http server, that give access to the files
  */
object FileIO {

    import com.orch.utils.{Path, Exe}
    val nb_slot = 10
    var nb_sending = 0
    var nb_recv = 0
    var current_recv : Map [Int, (Exe, Long)] = Map ()
    var current_send : Map [Int, (Exe, Long)] = Map ()

    var send_list : Queue [Exe] = Queue ()
    var used_port : List [Int] = List ()


    def uniform (low : Int, high : Int) : Int = {
        val x = scala.util.Random.nextInt % (high - low)
        if (x < 0) -x + low
        else x + low
    }

    /**
      * Enqueue a new sending file in the waiting list
      * If there is an available slot, it launch the receiving
      */
    def launchRecv () : Unit = {
        this.send_list.synchronized {
            if (nb_sending < nb_slot && send_list.length != 0) {
                val fst = send_list.dequeue
                nb_sending += 1
                fst.start ()
            } else {
            }
        }
    }

    /**
      * Start the Http server that give access the the files
      */
    def startServer (path : String = "/tmp/", port : Int = 8000) {
        new Exe (Seq ("ruby", "-run", "-ehttpd", path, s"-p$port"), Path ("."),
            (_,_,_) => {},
            (msg,_) => {
                false
            }
        ).start ()
        Thread.sleep (1000)
    }

    /**
      * Trigger that is triggered when a file has been received
      * It call launchRecv
      */
    def onRecvEnd () : Unit = {
        this.send_list.synchronized {            
            nb_sending -= 1
            launchRecv ()
        }
    }

    /**
      * Receive an input file
      * Unlike the normal files, that are generated by tasks, input file can have differently formatted path 
      * Params : 
      * - ref, the reference to the master module
      * - mid, the id of the node module (use when communicating with master module)
      * - id, the id of the file
      * - DAddr, the remote node that possess the file we want to retreive
      * - srcPath, the path of the file we want to retreive
      * - user, the user that will use this file
      * - dstTask, the task that will use this file
      * - dstFile, the name of the file after recv
      */
    def recvFile (ref : ActorSelection, mid : String, wid : String, id : String, addr : String, port : Int, srcPath : String, user : String, task : Array [Long]) : Unit = {
        val remote_file = new java.io.File (srcPath);
        val path = Path.buildStr (Seq (Global.user_home, user, wid, "files")).file;
        val filePath = Path.buildStr (Seq ("/", path, remote_file.getName ())).file;
        val exe = new Exe (Seq ("mkdir", "-p", path), Path ("."), 
            (code, out, err) => {
                new Exe (Seq ("curl", (addr + ":" + port) + srcPath, "-o", filePath), Path("."),
                    (code, out, err) => {
                        // Copy all files to correcto location
                        Future {
                            for (t <- task) {
                                val task_path = Path.buildStr (Seq (Global.user_home, user, wid, "" + t)).file;
                                val sec_path = Path.buildStr (Seq (Global.user_home, user, wid, "" + t, remote_file.getName ())).file;
                                val file = new java.io.File (task_path);
                                file.mkdirs ()

                                val cp = new Exe (Seq ("cp", filePath, sec_path), Path ("."));
                                cp.synchro ();
                            }
                            ref ! DaemonProto.FileSent (mid, wid, id, task)
                        }
                        onRecvEnd ()
                    },
                    (msg,_) => {
                        false
                    }
                ).start ()
            },
            (msg, _) => {                
                false
            }
        )

        this.send_list.synchronized {
            send_list.enqueue (exe)
        }

        launchRecv ()
    }


    /**
      * Receive Exe is used to retreived executable 
      * Params : 
      * - remote, the ref of the master module
      * - mid, the name of the daemon node
      * - id, the id of the task
      * - DAddr, the address of the remote node that holds the executable
      * - args, the params that will be passed to the executable 
      * - srcPath, the source path of the executable on the remote node at addr : DAddr
      * - dstPath, the location where we want the executable to be stored
      */
    def recvExe (remote : ActorRef, mid : String, wid : String, id : Long, addr : String, port : Int, app : String, args : String, user : String, vid : Long) : Unit = {
        val dstPath = Path.buildStr (Seq (Global.user_home, user, wid, "" + id, "exec.tar")).file
        val file = new java.io.File (dstPath);
        val dir = file.getParent ()
        val exe = new Exe (Seq ("mkdir", "-p", dir), Path ("."),
            (code, out, err) => {
                println ("Exe : ", (addr + ":" + port) + app + " -o " + dstPath);
                val exe = new Exe (Seq ("curl", (addr + ":" + port) + app, "-o", dstPath), Path("."),
                    (code, out, err) => {
                        remote ! DaemonProto.ExeReceived (mid, wid, id, user, vid, args)
                    },
                    (msg,_) => {
                        false
                    }
                ).start ()
            },
            (msg, _) => {
                false
            }
        )

        exe.start ()
    }

}
