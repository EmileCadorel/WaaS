package com.orch.leader.scheduling

/**
  * A SVM is the scheduling information about a VM
  * It's generated by a scheduler, and is used to generated a CVM
  */
class SVM (val nid : String, val id : Long, val os : String, val user : String, val boot : Long) {

    /**
      * The list of tasks located in this VM
      */
    var tasks : Map [String, STask] = Map ()

    /**
      * The start of the VM = min (tasks.begin) - boot
      */
    var begin : Long = Long.MaxValue

    /**
      * The end time of the VM = max (tasks.end)
      */
    var end : Long = 0

    /**
      *  The capacities of the VM, these capacities are generated by the needs of the STasks
      */
    var capas : Map [String, Long] = Map ()

    /**
      * The current load of the VM, for internal collisions
      */
    var currentLoad : Map [String, Array [Interval]] = Map ()
    
    /**
      * Create a new VM by adding or updating the STask /task/
      */
    def updateByAdding (task : STask) : SVM = {
        val auxVM = new SVM (nid, id, os, user, boot)
        auxVM.currentLoad = currentLoad

        for (n <- task.needs) {
            val array = (if (currentLoad.contains (n._1)) currentLoad (n._1) else Array ()) :+ new Interval (task.begin, task.end, n._2)
            auxVM.currentLoad = auxVM.currentLoad + (n._1->  IntervalUtils.allIntersect (array))
        }

        for (n <- auxVM.currentLoad) {
            auxVM.capas = auxVM.capas + (n._1-> IntervalUtils.maxIntervalOnIntersect (n._2))
        }

        if (task.end > end)
            auxVM.end = task.end
        else auxVM.end = end

        if (task.begin - boot < begin)
            auxVM.begin = task.begin - boot
        else auxVM.begin = begin

        auxVM.tasks = tasks + ((task.ref.id + "@" + task.ref.wid) -> task)
        auxVM
    }

    def getUsage () : Map [String, Array [Interval]] = {
        currentLoad
    }

    /**
      * The capacity of the vm on the hardware /hw/
      */
    def getCapacity (hw : String) : Long = {
        if (capas.contains (hw))
            capas (hw)
        else 0
    }
    
    def getCapacities () : Map [String, Long] = {
        capas
    }

    def getBegin () : Long = {
        begin
    }

    def getEnd () : Long = {
        end
    }

    def getBoot () : Long = {
        boot
    }

    def prettyPrint () : String = {
        s"VM : $id @${user}:${os} {${capas}} [$begin; $end[ => (${tasks.size})"
        // val us = IntervalUtils.prettyFormat (currentLoad ("cpus"))
        // val inter = tasks.map (x => new Interval (x._2.begin, x._2.end, x._2.needs ("cpus")))        
    }

}

