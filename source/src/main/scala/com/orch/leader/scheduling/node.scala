package com.orch.leader.scheduling


/**
  * A SNode is the scheduling information about a Node
  * It generated by a scheduler, and is used to generate a CNode
  */
class SNode (val name : String, val cluster : String, val capas : Map [String, Long], val speed : Int) {

    /**
      * The list of SVMs, in this machine, 
      */
    var vms : Map [Long, SVM] = Map ()

    /**
      * The usage of a node is based on its capacities, 
      * It has an array of usage for each capacity
      * The usage is the number of resources used for a period of time that is represented by an interval
      */
    var currentLoad : Map [String, Array [Interval]] = Map ();


    /**
      * Create a new SNode, that contains the old informations and the
      * new information about the VM /vm/
      */
    def updateByAdding (vm : SVM) : SNode = {
        val auxNode = new SNode (name, cluster, capas, speed)
        val updateVM = vms.contains (vm.id)
        val rmVM = if (updateVM) vms (vm.id) else null
        auxNode.vms = vms + (vm.id -> vm)

        for (c <- capas) {
            var array : Array [Interval] = if (currentLoad.contains (c._1))
                currentLoad (c._1)
            else Array ()

            // The load of the new VM
            array = array :+ new Interval (vm.getBegin (), vm.getEnd (), vm.getCapacity (c._1));
            if (updateVM) // We need to remove the anc vm from the usage                
                array = array :+ new Interval (rmVM.getBegin (), rmVM.getEnd (), -rmVM.getCapacity (c._1))

            auxNode.currentLoad = auxNode.currentLoad + (c._1-> IntervalUtils.allIntersect (array))
        }

        auxNode
    }

    /**
      * Remove all the old vms, whose end are < time
      */
    def removeAllOldVM (time : Long) : SNode = {
        val auxNode = new SNode (name, cluster, capas, speed)
        auxNode.vms = vms.filter ((t) => (t._2.getEnd () >= time))
        for (c <- capas) {
            var array : Array [Interval] = Array ()
            for (v <- auxNode.vms)
                array = array :+ new Interval (v._2.getBegin (), v._2.getEnd (), v._2.getCapacity (c._1))
            auxNode.currentLoad = auxNode.currentLoad + (c._1 -> IntervalUtils.allIntersect (array))
        }

        auxNode
    }

    /**
      * Remove a vm if it exists in the node
      */
    def removeVM (vm : SVM) : SNode = {
        if (vms.contains (vm.id)) {
            val auxNode = new SNode (name, cluster, capas, speed)
            auxNode.vms = vms.filter (_._1 != vm.id)
            for (c <- capas) {
                val array = (if (currentLoad.contains (c._1)) currentLoad (c._1) else Array ()) :+ new Interval (vm.getBegin (), vm.getEnd (), -vm.getCapacity (c._1));

                auxNode.currentLoad = auxNode.currentLoad + (c._1-> IntervalUtils.allIntersect (array))
            }

            auxNode
        } else {
            val auxNode = new SNode (name, cluster, capas, speed)
            auxNode.vms = vms;
            auxNode.currentLoad = currentLoad;
            auxNode
        }
    }

    /**
      * Returns : the current usage of the node
      */
    def getUsage () : Map [String, Array [Interval]] = {
        currentLoad
    }

    /**
      * Returns : the capacities of the node
      */
    def getCapacities () : Map [String, Long] = {
        capas
    }

    def getVMs () : Map [Long, SVM] = {
        vms
    }

    def getVM (id : Long) : SVM = {
        vms (id)
    }

    def prettyPrint () : String = {
        var ret = "";
        for (v <- vms)
            ret = ret + v._2.prettyPrint () + "\n";
        ret
    }

}
